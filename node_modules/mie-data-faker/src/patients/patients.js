import { faker } from '@faker-js/faker';
import moment from 'moment';


export function createPatients() {

    // assign a patient sex at time of function call
    const sex = faker.name.sex();

    return {
        first_name: faker.name.firstName(sex),
        last_name: faker.name.lastName(),
        middle_name: faker.name.firstName(sex),
        title: faker.helpers.arrayElement(['', faker.name.prefix(sex)]),
        suffix: faker.helpers.arrayElement(['', faker.name.suffix()]),
        address1: faker.address.streetAddress(),
        county: faker.address.county(),
        city: faker.address.city(),
        state: faker.address.stateAbbr(),
        zip_code: faker.address.zipCode(),
        home_phone: faker.phone.number(),
        work_phone: faker.phone.number(),
        cell_phone: faker.phone.number(),
        fax_number: faker.phone.number(),
        alternate_phone: faker.phone.number(),
        email: faker.internet.email(),
        sex: sex[0].toUpperCase(),
        ssn: faker.datatype.number({min: 100000000, max: 999999999}),
        marital_status: faker.helpers.arrayElement(['M', 'S', 'D', 'W', 'P']),
        get spouse_name() {
            if (this.marital_status === 'M' || this.marital_status === 'P') {
                return faker.name.firstName();
            } else {
                return '';
            }
        },
        get spouse_birthdate() {
            if (this.marital_status === 'M' || this.marital_status === 'P') {
                return moment(faker.date.past(75)).format('YYYY-MM-DD HH:mm');
            } else {
                return '0000-00-00 00:00:00';
            }
        },
        get emergency_contact() {
            if (this.marital_status === 'M') {
                return this.spouse_name;
            } else {
                return '';
            }
        },
        emergency_phone: faker.phone.number(),
        employment_status: faker.helpers.arrayElement(['E', 'R', 'S', 'U']),
        get employer_name() {
            if (this.employment_status === 'E') {
                return faker.company.name();
            } else {
                return '';
            }
        },
        get employer_addr1() {
            if (this.employment_status === 'E') {
                return faker.address.streetAddress();
            } else {
                return '';
            }
        },
        get employer_county() {
            if (this.employment_status === 'E') {
                return faker.address.county();
            } else {
                return '';
            }
        },
        get employer_city() {
            if (this.employment_status === 'E') {
                return faker.address.city();
            } else {
                return '';
            }
        },
        get employer_state() {
            if (this.employment_status === 'E') {
                return faker.address.stateAbbr();
            } else {
                return '';
            }
        },
        get employer_zipcode() {
            if (this.employment_status === 'E') {
                return faker.address.zipCode();
            } else {
                return '';
            }
        },
        get employer_country() {
            if (this.employment_status === 'E') {

                // 90% of the time, the employer country will be US
                const countryIdx = faker.datatype.number({min: 0, max: 10}) > 1 ? 1 : 0;

                return [faker.address.countryCode(), 'US'][countryIdx];
            } else {
                return '';
            }
        },
        interface: 'MIE DataFaker',
        birth_date: moment(faker.date.past(75)).format('YYYY-MM-DD HH:mm'),
        death_indicator: faker.datatype.number({min: 0, max: 10}) > 1 ? 1 : 0,
        get death_date() {
            if (this.death_indicator) {
                return moment(faker.date.between(
                    this.birth_date,
                    moment()
                )).format('YYYY-MM-DD HH:mm');
            } else {
                return '0000-00-00 00:00:00';
            }
        },
        get active() {
            if (this.death_indicator) {
                return 0;
            } else {
                return 1;
            }
        },
        is_patient: 1,
        create_date: moment().format('YYYY-MM-DD HH:mm')

        // commented out fields are those found in the appointments table but are not currently used

        // revision_number
        // gurantor_id
        //extern_id1
        // first_name_phn
        // last_name_phn
        // preferred_first_name * Consider using nickname mappings for nicknames (preferred_first_name)
        // degree
        //attending_physician
        // referring_physician
        // family_physician
        // address2
        // address3
        // cellco_id
        // preferred_alert_method
        // race
        // sin
        // chart_online
        // signature_date
        // edit_date
        // revised_by
        // username
        // universal_id
        // license_number
        // dea_number
        // nat_pro_id
        // tax_id_number
        // pager

    };
};
