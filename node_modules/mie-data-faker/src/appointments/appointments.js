import { faker } from '@faker-js/faker';
import moment from 'moment';


export function appointmentIntervals(startString, endString, duration) {
    const start = moment(startString, 'YYYY-MM-DD hh:mm a');
    const end = moment(endString, 'YYYY-MM-DD hh:mm a');

    // round starting minutes up to nearest 
    // if duration is 15: (00:12 --> 00:15, 00:17 --> 00:30))
    start.minutes(Math.ceil(start.minutes() / duration) * duration);

    const result = [];

    const current = moment(start);

    while (current <= end) {
        const tempStart = current.format('YYYY-MM-DD HH:mm');
        current.add(15, 'minutes');
        const tempEnd = current.format('YYYY-MM-DD HH:mm');
        result.push([tempStart, tempEnd]);
    };

    return result;
};

// TODO: think of a way to use fewer args
export function createAppointments(start, end, patIds, reasons, userIds) {
    
    return {
        pat_id: faker.helpers.arrayElement(patIds),
        startdate: start,
        enddate: end,
        reason: faker.helpers.arrayElement(reasons),
        location: 'OFFICE',      
        canceled: faker.datatype.number({min: 0, max: 5}) > 1 ? 0 : 1,
        contact: faker.name.firstName(),
        contact_number: faker.phone.number(),
        comment: faker.lorem.sentence(),
        patient_instructions: faker.lorem.sentence(),
        user_id: faker.helpers.arrayElement(userIds),
        createdate: moment().format('YYYY-MM-DD HH:mm'),
        recurrence: 0

    // commented out fields are those found in the appointments table but are not currently used

        // waitlist_duedate
        // pat_duration
        // remind
        // status
        // cancel_code
        // confirmed
        // confirm_user
        // confirm_date
        // day_overlap
        // rc_interval
        // rc_instance
        // rc_dow
        // rc_enddate
        // rc_numoccur
        // visible_date
    };
};
